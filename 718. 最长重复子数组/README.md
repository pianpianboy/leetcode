# 解题思路

## 我的解题思路
毫无思路，看网上说这是一道DP入门题，看来还是自己太菜了，连基本的DP思路都没有。
要搞清楚，公共子序列与公共子串的区别：
1. 最长公共子序列与最长公共子串的区别在于最长公共子序列不要求在原字符串中是连续的，比如ADE和ABCDE的最长公共子序列是ADE。
2. 首先区分下公共字串和公共子序列的区别，公共子序列是在整个字符串中只要按照顺序可以不用连续的，但是公共子串是指必须连续的字符串，举个例子

ABCBDAB
BDCABA
公共子序列是  BCBA

公共字串是  AB

求公共字串比公共子序列稍微简单了一些，如果上边所述，公共子串也可以用暴力匹配方法，求出较短的字符串的所有子串，然后可以从长到短利用kmp字符串匹配算法求出公共子串，同时还添加了剪枝，但是字样的暴力匹配效率始终是比较差的，最好的方法还是使用动态规划。

根据上边公共子序列动态规划的方法分析，其实我们可以发现公共子串和公共子序列非常类似

只是在状态转移方程是稍有不同，

## 参考解题思路
1. 思路分析： 这显然是一道动态规划的题，蛋式可能会有很大一部分的道友做错，会把“子数组”、
“子序列”混淆。“子数组”要求连续，“子序列”并不要求连续。
所以dp[i][j]应该表示当A[i - 1] == B[j - 1]时，A[0, i -1],B[0, j - 1]连续的重复子数组长度。
2. 这道题式求最长公共子串的问题，最长连续子串要求这个子串是连续的，那么在动态规划的思想下，设置d[i][j]为A中i为结束和B中以j为结束位置的字符串的最长连续子串长度。
3. 状态转移方程为：dp[i][j] = a[i]==b[j]? dp[i-1][j-1] + 1: 0;


# 类比题目
## 最长连续子序列问题 LCS
给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

示例 1:

输入: "sea", "eat"
输出: 2
解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"
说明:

给定单词的长度不超过500。
给定单词中的字符只含有小写字母。
https://blog.csdn.net/xuxuxuqian1/article/details/81072967