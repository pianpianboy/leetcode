# Kafka

##Kafka核心技术与实战

### 客户端实践与原理剖析

#### 无消息丢失配置怎么实现
##### kafka到底在什么情况下才能保证消息不丢失？
- 一句话概括，Kafka只对『只提交』的消息（committed message）做有限度的持久化保证。
- 总结下：kafka是能做到不丢失消息的，只不过这些消息必须市已提交的消息，而且还要满足一定的条件

##### kafka消息丢失案例
###### 案例1：生产者程序丢失数据
- 目前kafka producer是异步发送消息的，也就是说如果你调用的是producer.send(msg)这个API,那么它通常会立即返回，但此时你不能认为消息发送已经成功完成
- 如果有那个这个方式，可能由于网络抖动，导致消息压根就没有发送到Broker端；或者消息本身不合格导致Broker拒绝接收（比如消息太大了，超过了Broker的承受能力）
- 解决此问题的方法非常简单：Producer用用要使用带有回调通知的发送API，也就是说不要使用producer.send(msg)，而要使用producer.send(msg,callback)。不要小瞧这里的callback（回调），它能准确地告诉你消息是否真的提交成功了，一旦出现消息提交失败的情况，可以有针对性地进行处理。

###### 案例2：消费者程序丢失数据
- Consumer 程序有个"位移"的概念，表示的是这个Consumer当前消费到Topic分区的位置
    + 这里的“位移”类似于我们看书时使用的书签，它会标记我们当前阅读了多少页，下次翻书的时候我们能直接跳到书签页继续阅读。
    + 正确使用书签有两个步骤：第一步是读书，第二步是更新书签页。如果这两步的顺序颠倒了，就可能出现这样的场景：当前的书签页是第 90 页，我先将书签放到第 100 页上，之后开始读书。当阅读到第 95 页时，我临时有事中止了阅读。那么问题来了，当我下次直接跳到书签页阅读时，我就丢失了第 96～99 页的内容，即这些消息就丢失了。
- 同理，Kafka中Consumer端的消息丢失就是这么一回事。要对抗这种消息丢失，办法很简单：维持先消费消息(阅读)，再更新位移（书签）的顺序即可。这样就能最大限度地保证消息不丢失。
- 当然，这种处理方式可能带来的问题是消息的重复处理，类似于同一页书读了很多遍，但这不属于消息丢失的情形。
- kafka还有一种比较隐蔽的消息丢失的场景
    + consumer程序从Kafka获得到消息后开启了多个线程异步处理消息，而Consumer程序自动地向前更新位移。假如其中某个线程运行失败了，他负责的消息没有被成功处理，但位移已经被更新了，因此这条消息对于Consumer而言实际上是丢失了。
    + 这里的关键在于Consumer自动提交位移，没有真正地确认消息是否真的被消费就盲目地更新了位移
- **这个问题的解决方案也很简单：**
    + 如果是多线程异步处理消费消息，Consumer程序不要开启自动提交位移，而是要应用程序手动提交位移。
    + 在这里我要提醒你一下，单个 Consumer 程序使用多线程来消费消息说起来容易，写成代码却异常困难，因为你很难正确地处理位移的更新，也就是说避免无消费消息丢失很简单，但极易出现消息被消费了多次的情况。

##### 最佳实践
- 不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。记住，一定要使用带有回调通知的 send 方法。
- 设置acks =all，acks是producer的一个参数，代表了你对『已提交』消息的定义。如果设置成all,则表明所有副本Broker都要接收到消息，该消息才算是"已提交"。
- 设置retries为一个较大的值。这里的retries同样是producer的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries > 0 的 Producer 能够自动重试消息发送，避免消息丢失。
- 设置unclean.leader.election.enable= false. 这个是Broker端的参数，控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。
- 设置replicaiton.factor>3。这也是Broker端的参数。其实这里想表述的是，最好将消息多保存几份，毕竟目前防止消息丢失的主要机制就是冗余。
- 设置min.insync.replicas>1。这依然是Broker端参数，控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。
- 确保消息消费完成再提交。Consumer端有个参数 enable.auto.commit，最好把它设置成false,并采用手动提交位移的方式
