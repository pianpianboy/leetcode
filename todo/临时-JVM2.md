# 大对象占用大量Eden区域的案例

## 案例描述
有一次投产上线之后第二天，数据中心监控报警平台收到大量的报警，发现线上系统所在的机器的cpu负载非常的高，持续走高，甚至导致机器宕机了，重启后过了半天又开始CPU使用率飙升，所有系统对应的前端页面都无法访问了。

## 生产事故分析
### 线上系统的机器CPU负载过高的两个常见场景
- 第一个场景：在系统里创建了大量的线程，这些线程同时并发工作，而且工作负载很重，过多的线程同时并发运行就会导致你的机器CPU负载过高。
- 第二个场景，就是你的机器上运行的JVM在执行频繁的Full GC，Full GC是非常耗费CPU资源的，他是一个非常重负载的操作；
所以一旦你的JVM有频繁的Full GC，带来的一个明细的感觉，一个是系统可能时不时会卡死，因此Full GC会带来一定的Stop world问题，一个是机器的CPU负载很高


### 通过jstat对线上系统进行分析，发现频繁Full GC
- 利用jstat可以直接看线上系统运行时候的动态内存变化模型，
- 基于stat分析发现：
    + 4C 8G的机器，堆内存分配了4G，新生代分配了3G,老年代1个G，Eden和survivor的比例是4：1：1，Eden区域2G,s1和s2分别为500M
    + Eden区域大概1分钟就被塞满，然后就会触发一次Young GC,而且Young GC之后就会有将近1G的存活对象进入老年代，而此时老年代设置的是占比达92%就触发cms垃圾回收
    + 然后就会触发一次Full GC，然后停顿500ms
    + 基本上就是1分钟停顿500ms
    + 线上4C的机器根本撑不住这么频繁而且耗时的Full GC,所以这种长时间且频繁的Full GC导致机器的CPU被频繁打满，负载过高。

### 如果有频繁的Full GC问题，一般可能性有三个
- 内存分配不合理，导致对象频繁进入老年代，进而引发频繁的Full GC;
- 系统中有大对象，大对象直接进入老年代，并占用了老年代大量的空间，直接触发了频繁的Full GC
- 存在内存泄漏等问题，就是内存里驻留了大量的对象塞满了老年代，导致稍微有些对象进入老年代就会引发Full GC
- 永久代（metaspace或者perm）里类太多，触发了Full GC
- 或者代码钟错误的执行了System.gc()导致的，这个一般很少见，在JVM的 参数钟可以禁止这种显示的触发GC.

### JVM调优
- 其实这个系统的GC参数是已经优化过一次之后，感觉Eden区域对象的增加速度考虑，不应该是JVM参数的问题，即使再进行JVM参数调优应该也没办法解决问题
- 此时应该要做的是使用MAT工具对内存进行分析，分析是什么原因导致了系统加载了过多的数据进入内存钟。
- 明确：这是明细的代码层面的问题了，其实要优化这个事故，就必须得优化代码，而不是简单的JVM参数

### 示范代码
```java
public class JVMDemo2 {
    static class Data{}
    public static void main(String[] args) throws InterruptedException {
        List<Data> datas = new ArrayList<Data>();
        for(int i=0;i<10000;i++){
            datas.add(new Data());
        }
        Thread.sleep(1*60*60*1000);
    }
}
```

### 使用JMap
- jmap -dump:live,format=b,file=dump.hprof 38743

## 使用MAT
- open -a mat.app --args -data ~/workspace/Tools/heapdump/
我们根据MAT中的信息，追踪到线上系统某个线程的执行堆栈，最终发现的是这个线程执行"String.split()"方法导致产生了大量的对象
为什么String.split()方法会产生大量对象
JDK1.6的时候：
String。split()方法的实现是这样子的，比如你有一个字符串，"Hello World Ha Ha"，然后你按照空格来切割这个字符串，应该会出来四个字符串"Hello" "world" "Ha" "Ha"，"Hello World Ha Ha"，这个字符串底层是基于一个数组来存放那鞋字符的，比如比如[H,e,l,l,o,,W,o,r,l,d,,H,a,,H,a]这样的数组。然后切割出来的"Hello"字符串他不会对应一个新的数组，而是直接映射到原来那个字符串的数组。采用偏移量表明自己是对应原始数组钟的那些元素。
比如说"Hello" 字符串可能就是对应[H,e,l,l,o,,W,o,r,l,d,,H,a,H,a]数组中的0~4位置的元素

但是JDK1.7的时候：



其实原因很简单，当时这个线上系统用的是JDK 1.7。


比如说“Hello”字符串可能就是对应[H,e,l,l,o,,W,o,r,l,d,,H,a,H,a]数组中的0~4位置的元素。

但是JDK 1.7的时候，他的实现是给每个切分出来的字符串都创建一个新的数组，比如“Hello”字符串就对应一个全新的数组，[H,e,l,l,o]。

所以当时那个线上系统的处理逻辑，就是加载大量的数据出来，可能有的时候一次性加载几十万条数据，数据主要是字符串

然后对这些字符串进行切割，每个字符串都会切割为N个小字符串。

这就瞬间导致字符串数量暴增几倍甚至几十倍，这就是系统为什么会频繁产生大量对象的根本原因！！！

因为在本次系统升级之前，是没有String.split()这行代码的，所以当时系统基本运行还算正常，其实一次加载几十万条数据量也很大，当时基本上每小时都会有几次Full GC，不过基本都还算正常。

只不过系统升级之后代码加入了String.split()操作，瞬间导致内存使用量暴增N倍，引发了上面说的每分钟一次Young GC，两分钟一次Full GC，根本原因就在于这行代码的引入。

