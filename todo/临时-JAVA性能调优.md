# Java性能调优

## java编程性能调优

### 网络通信优化之IO模型：如何解决高并发下IO瓶颈
#### 什么是I/O

#### 传统I/O的性能问题
I/O 操作分为磁盘 I/O 操作和网络 I/O 操作。前者是从磁盘中读取数据源输入到内存中，之后将读取的信息持久化输出在物理磁盘上；后者是从网络中读取信息输入到内存，最终将信息输出到网络中。但不管是磁盘 I/O 还是网络 I/O，在传统 I/O 中都存在严重的性能问题。
##### 1.多次内存复制
在传统I/O中，我们可以通过InputStream从源数据中读取数据流输入到缓冲区里通过OutputStream将数据输出到外部设备，其中输入操作在操作系统中的具体流程如图：
user space --1.read()syscall--> kernel space----2.ask for data---> Hardware
user space <--4.copy data to user buffer-- kernel space<----3.data to kernel buffer thoug DMA--- Hardware

- JVM会发出read()系统调用，并通过read系统调用向内核发起读请求；
- 内核向硬件发送读指令，并等待读就绪；
- 内核把将要读取的数据复制到指向的内核缓存中
- 操作系统内核将数据复制到用户空间缓冲区，然后read系统调用返回

在这个过程中，数据先从外部设备复制到内核空间，在从内核空间复制到用户空间，这就发生了两次内存复制操作，这种操作会导致不必要的数据拷贝和上下文切换，从而降低了I/O的性能

##### 1.阻塞
- 在传统的I/O中，InputStream的read()是一个while循环操作，它会一直等待数据读取，直到数据就绪才会返回。**这就意味着如果没有数据就绪，这个读取操作将会一直被挂起，用户线程处于阻塞状态。**
- 在少量连接请求的情况下，使用这种方式没有问题，响应速度也很高。但是在发生大量连接请求时，就需要创建大量监听线程，这时如果线程没有数据就绪就会被挂起，然后进入阻塞状态。一旦发送线程阻塞，这些线程将会不断地抢夺CPU资源，从而导致大量的cpu上下文切换，增加系统的性能开销。

#### 如何优化I/O操作
JDK1.4发布了java.nio nio的发布优化了内存复制以及阻塞导致的严重性能问题。
JDK1.7发布了NIO2,提出从操作系统层面实现异步I/O.
在 JDK1.7 版本中，Java 发布了 NIO 的升级包 NIO2，也就是 AIO。AIO 实现了真正意义上的异步 I/O，它是直接将 I/O 操作交给操作系统进行异步处理。这也是对 I/O 操作的一种优化，***那为什么现在很多容器的通信框架都还是使用 NIO 呢？**
异步I/O模型在linux内核中没有实现。

##### 1.使用缓冲区优化读写流操作
- 在传统的I/O中，提供了基于流的I/O实现，即InputStream和OutputStream，这种基于流的实现以直接为单位处理数据。
- Nio与传统的I/O不同，它是基于块（Block）的，它以块为基本单位处理数据。在NIO中，最为重要的两个组件是缓冲区（Buffer）和通道(Channel)。Buffer是一块连续的内存块，是NIO读写数据的中装地。Channel表示缓冲数据的源头或者目的地，用于读取缓冲或者写入数据，是访问缓冲的接口。
- 传统I/O和NIO的最大区别就是传统I/O是面向流，NIO是面向Buffer.Buffer可以将文件一次性读取内存再做后续处理，而传统的方式是边读文件边处理数据。虽然传统I/O后面也使用了缓冲块。例如BufferedInputStream，但是性能人不尽人意

##### 2.使用DirectBuffer减少内存复制
- NIO的Buffer除了做了缓冲块优化之外，还提供了一个可以直接访问物理内存的类DirectBuffer.普通的Buffer分配的是JVM堆内存，而DirectBuffer是直接分配物理内存。
- 我们知道数据要输出到外部设备，必须先从用户空间复制到内核空间，再复制到输出设备，而DirectBuffer则是直接将步骤简化为从内核空间复制到外部设备，减少了数据拷贝
- 由于DirectBuffer申请的是非JVM的物理内存，所以创建和销毁的代价很高。DirectBuffer申请的内存并不是直接由JVM负责垃圾回收，但在DirectBuffer包装类被回收时，会通过 **Java Reference机制来释放该内存块** 。

##### 3.避免阻塞，优化I/O操作
- NIO很多人也称之为Non-block I/O，即非阻塞I/O，因为这样叫，更能体现它的特点。为什么这么说呢？
    + 传统的I/O即使使用了缓冲块，依然存在阻塞的问题。由于线程池线程数量有限，一旦发生了大量的并发请求，超过了最大数量的线程只能等待，直到线程池中有空闲的线程可以被复用。而对Socket的输入流进行读取时，读取流会一直阻塞，直到发生以下三种情况任意一种才会接触阻塞。
        * 有数据可读
        * 连接释放
        * 空指针或者I/O异常
- 阻塞问题，就是传统I/O最大的弊端。NIO发布后，通道和多路复用器这两个基本组件实现了NIO的非阻塞。
    + 通道(channel)
    + 多路复用器（Selector）

#### 总结