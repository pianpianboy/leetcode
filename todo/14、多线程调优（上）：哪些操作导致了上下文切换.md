


## 案例
刚入职上家公司的时候，恰好赶上一次抢购活动，这是系统重构上线后经历的第一次高并发考验，如期出现了大量超时报警，不过比我们预料的要更好一点，起码没有挂掉重启。

通过工具分析，我发现cs（上下文切换每秒次数）指标已经接近了60W次，平时的话最高5W。在通过日志分析，我发现了大量带有wait()的Exception,由此初步怀疑是大量线程处理不及时导致的，进一步锁定问题是连接池大小设置不合理。后来就模拟生产环境配置，对连接数进行压测进行调节，降低最大线程数，最后系统的性能就上去了。

在生产实践中总结经验，我知道了在并发程序中，并不是启动更多的线程就能让程序最大限度地并发执行。线程数量设置太小，会导致程序不能充分地利用系统资源；现成数量设置太大，有可能带来资源的过度竞争，导致上下文切换带来额外的系统开销。

## 初始上下文切换，什么是上下文切换
### 什么是时间片
cpu时间片是cpu分配给每个线程执行的时间段，一般为几十毫秒。在这么短的时间内线程相互切换，我们根本感觉不到，所以看上去就好像同时进行的一样。

其实在单个处理器时期，操作系统就能处理多线程任务。处理器给每个线程分配CPU时间片（Time Slice）,线程在分配获得的时间片内执行任务。

<font color=red >时间片决定了一个线程连续占用处理器的时长，</font>

### 线程的上下文切换
当一个线程的时间片用完了，或者因为自身的原因被迫暂停运行了，这个时候，另外一个线程（可以是同一个线程或者其它进程的线程）就被会被操作系统选中，来占用cpu，这种一个线程被暂停剥夺使用权，另外一个线程被选中开始或者继续运行的过程就叫做上下文切换（Context Switch）

### 上下文中有哪些内容呢？
- 包括寄存器的存储内容：CPU寄存器负责存储已经、正在和将要执行的任务
- 程序计数器存储的指令内容：程序计数器负责存储cpu正在执行的指令位置已经即将执行的下一条指令的位置

### 进程的上下文切换
Syncrhonized在轻量级锁之前，锁资源产生的是线程上下文切换，一旦升级到重量级锁，就会产生进程上下文切换。

**为什么synchronized升级为重量级锁之后就是进程间上下文切换？**

- 进程上下文切换，是指用户态和内核态的来回切换。当synchronized说资源竞争激烈，线程将会被阻塞，阻塞的线程将会从用户态调用内核态，尝试获取mutex，这个进程是syncrhonized锁产生的进程上下文切换。


## 多线程上下文切换诱因
## 发现上下文切换
## 总结