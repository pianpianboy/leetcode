# 解题思路

# 我的解题思路
使用递归的解题思路+使用非递归的解题思路
但是第一次没能写出来
后面：由于搜索二叉树的中序遍历是有序的并且是升序的。因此先写出二叉树的中序遍历（非递归版本的），然后在非递归版本的基础上进行改造。
时间复杂度为O(logn),空间复杂度为O(n)

# 参考的解题思路
参考左神的解题思路
网上还有时间复杂度为O(n)，空间复杂度为O(1)
也是利用了递归的思想，分别对每一个子树进行判断，但是它的亮点在于在判断的时候并不需要对子树进行搜索“最相近的值”，而是利用了“最大值”、“最小值”的思想：

对于每个子树，都有一个最大值和一个最小值，

对于左子树，最大值就是它的根节点的值，最小值是根节点的最小值（左父亲或者MIN_VALUE）

对于右子树，最小值就是它的根节点的值，最大值是根节点的最大值（右父亲或者MAX_VALUE）

例如：

　　 5
   / \
  1   6
     / \
    3   7
5的满足小于最大值，大于最小值，然后递归（1，MIN，5） && 递归（4，5，MAX）
。。。
3节点的最大值为6，最小值应该为5,此时不满足，所以return false

其实还有一种非递归的解法：中序遍历，利用二叉搜索树中序遍历的有序性（在中序遍历的出栈时判断此值是否小于之前出栈的那个节点的值）